<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å”é¢¨èŠ±éˆ¿ AR è©¦å¦ (è™›æ“¬èƒŒæ™¯ç‰ˆ)</title>
    <!-- 1. å¼•å…¥ Face Mesh (äººè‡‰) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <!-- 2. å¼•å…¥ Hands (æ‰‹å‹¢) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- 3. å¼•å…¥ Selfie Segmentation (äººåƒåˆ†å‰²/èƒŒæ™¯æ›¿æ›) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js" crossorigin="anonymous"></script>
    
    <style>
        /* --- å…¨å±€æ¨£å¼ --- */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            background: #1a1a1a;
            font-family: "Kaiti", "STKaiti", "Songti TC", "Noto Serif TC", serif;
            overflow: hidden;
            color: #f0e6d2;
            cursor: none; /* éš±è—ç³»çµ±é¼ æ¨™ */
        }

        /* --- æ‰‹å‹¢å…‰æ¨™ --- */
        #hand-cursor {
            position: fixed;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            background: rgba(255, 215, 0, 0.5);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            display: none;
            transition: transform 0.1s, background 0.1s;
        }

        #hand-cursor.clicking {
            background: rgba(255, 50, 50, 0.9);
            transform: translate(-50%, -50%) scale(0.6);
            border-color: #ff5252;
        }

        /* --- å·¦å´ï¼šé¡å­å€åŸŸ --- */
        #stage-container {
            flex: 3;
            position: relative;
            margin: 10px;
            border: 4px solid #5d4037; 
            border-radius: 12px;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #input-video { display: none; }

        #output-canvas {
            width: 100%;
            height: 100%;
            object-fit: contain; 
            transform: scaleX(-1); /* é¡åƒç¿»è½‰ */
        }

        /* --- å³å´ï¼šå¦å¥©å€åŸŸ --- */
        #menu-container {
            flex: 1;
            min-width: 250px;
            max-width: 320px;
            background: #3e2723;
            border-left: 2px solid #8d6e63;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-y: auto;
            z-index: 20;
            user-select: none;
        }

        h1 {
            font-size: 1.5rem;
            margin: 10px 0;
            color: #ffcc80;
            letter-spacing: 3px;
            text-align: center;
        }

        p.subtitle {
            font-size: 0.8rem;
            color: #d7ccc8;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 10px;
            width: 100%;
            text-align: center;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            width: 100%;
            padding-bottom: 20px;
        }

        .huadian-btn {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #8d6e63;
            border-radius: 8px;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .huadian-btn.hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
            border-color: #fff;
        }

        .huadian-btn.active {
            border-color: #ffd54f;
            background: rgba(255, 213, 79, 0.2);
            box-shadow: 0 0 10px rgba(255, 213, 79, 0.3);
        }

        .huadian-btn img {
            width: 60%;
            height: 60%;
            object-fit: contain;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.5));
            margin-bottom: 5px;
            pointer-events: none;
        }

        .huadian-name { font-size: 0.8rem; color: #e0e0e0; pointer-events: none; }

        .reset-btn {
            margin-top: auto;
            margin-bottom: 10px;
            padding: 10px 30px;
            background: transparent;
            border: 1px solid #ffcc80;
            color: #ffcc80;
            font-family: inherit;
            cursor: pointer;
            transition: 0.3s;
            border-radius: 50px;
        }
        
        .reset-btn.hover { background: #ffcc80; color: #3e2723; }

        /* è¦†è“‹å±¤ */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            text-align: center;
            padding: 20px;
        }

        #status-text {
            color: white;
            font-size: 1.1rem;
            margin-bottom: 30px;
            line-height: 1.6;
            max-width: 80%;
        }

        #start-btn {
            padding: 12px 30px;
            font-size: 1.1rem;
            background: linear-gradient(to right, #d84315, #bf360c);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(191, 54, 12, 0.5);
            font-family: inherit;
            display: none;
        }

        @media (max-width: 768px) {
            body { flex-direction: column; }
            #stage-container { flex: 2; width: 100%; margin: 0; border: none; border-radius: 0; }
            #menu-container { 
                flex: 1; 
                width: 100%; 
                max-width: none;
                border-left: none; 
                border-top: 2px solid #8d6e63;
                flex-direction: row; 
                overflow-x: auto;
                padding: 10px;
                gap: 15px;
            }
            .grid-container { display: flex; width: auto; gap: 10px; padding-bottom: 0; }
            .huadian-btn { width: 80px; height: 80px; flex-shrink: 0; }
            h1, .subtitle, .reset-btn { display: none; }
        }
    </style>
</head>
<body>

    <div id="hand-cursor"></div>
    
    <div id="overlay">
        <div id="status-text">æ­£åœ¨ä½ˆç½®é¾é–€å¦å¥©...<br>(åŒæ™‚åŠ è¼‰: äººè‡‰è­˜åˆ¥ã€æ‰‹å‹¢è­˜åˆ¥ã€èƒŒæ™¯æ›¿æ›æ¨¡å‹)<br>âš ï¸ æ­¤æ¨¡å¼å°è¨­å‚™æ€§èƒ½è¦æ±‚è¼ƒé«˜</div>
        <button id="start-btn">é–‹å•Ÿé¡é ­ï¼Œå°é¡è²¼èŠ±é»ƒ</button>
    </div>

    <div id="stage-container">
        <video id="input-video" playsinline webkit-playsinline muted autoplay></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <div id="menu-container">
        <h1>å”é¢¨å¦å¥©</h1>
        <p class="subtitle">ğŸ‘‰ é£ŸæŒ‡æ‡¸åœé¸å– &nbsp; ğŸ¤ æåˆç¢ºèªä½©æˆ´</p>
        <div class="grid-container" id="options-grid"></div>
        <button class="reset-btn" id="btn-reset">å¸å¦ / å›æ­¸ç¾ä¸–</button>
    </div>

    <script>
        // --- 1. èŠ±éˆ¿èˆ‡è™›æ“¬èƒŒæ™¯é…ç½® ---
        // æˆ‘å€‘ä½¿ç”¨ Canvas Gradient ä¾†æ¨¡æ“¬å”æœå ´æ™¯ï¼Œé¿å…åŠ è¼‰å¤–éƒ¨åœ–ç‰‡å‡ºéŒ¯
        const huadianAssets = [
            {
                name: "æ¢…èŠ±å¦", // ç´…è‰²èŠ±éˆ¿
                // å·²ä¿®å¾© Base64
                src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8cGF0aCBkPSJNNTAgMjAgQzYwIDAgOTAgMjAgODAgNTAgQzkwIDgwIDYwIDEwMCA1MCA4MCBDNDAgMTAwIDEwIDgwIDIwIDUwIEMxMCAyMCA0MCAwIDUwIDIwIFoiIGZpbGw9IiNjYzAwMDAiIHN0cm9rZT0ibm9uZSIgb3BhY2l0eT0iMC44NSIvPgo8L3N2Zz4=",
                scale: 1.2, yOffset: -15,
                // èƒŒæ™¯ï¼šæ´›é™½ç‰¡ä¸¹èŠ±æµ·
                bgType: "peony"
            },
            {
                name: "é‡‘è±éˆ¿",
                src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8cGF0aCBkPSJNNTAgMTAgTDUwIDEwIEw5MCA1MCBMNTAgOTAgTDEwIDUwIFoiIGZpbGw9IiNmZmQ3MDAiIHN0cm9rZT0iI2ZmYjMwMCIgc3Ryb2tlLXdpZHRoPSIyIiBvcGFjaXR5PSIwLjkiLz4KICA8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI1IiBmaWxsPSIjZmZmIiAvPgo8L3N2Zz4=",
                scale: 1.0, yOffset: -10,
                // èƒŒæ™¯ï¼šå¤§æ˜å®®è©ï¼ˆå®®ç‰†ç´… + é‡‘è‰²ï¼‰
                bgType: "daming"
            },
            {
                name: "ç¿ ç¾½è“®",
                src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8cGF0aCBkPSJNNTAgMTAgQzcwIDMwIDgwIDYwIDUwIDkwIEMyMCA2MCAzMCAzMCA1MCAxMCBaIiBmaWxsPSIjMDA5OWNjIiBvcGFjaXR5PSIwLjgiLz4KICA8cGF0aCBkPSJNNTAgMTAgQzYwIDMwIDcwIDUwIDUwIDcwIEMzMCA1MCA0MCAzMCA1MCAxMCBaIiBmaWxsPSIjMDBiYmZmIiAvPgo8L3N2Zz4=",
                scale: 1.3, yOffset: -20,
                // èƒŒæ™¯ï¼šæ±Ÿå—ç…™é›¨ï¼ˆæ°´å¢¨é’ç¶ ï¼‰
                bgType: "jiangnan"
            },
            {
                name: "è¶æˆ€èŠ±",
                src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8cGF0aCBkPSJNNTAgNTAgQzcwIDMwIDkwIDMwIDkwIDUwIEM5MCA4MCA1MCA4MCA1MCA1MCBaIiBmaWxsPSIjZmY4MGFiIiBvcGFjaXR5PSIwLjgiIC8+CiAgPHBhdGggZD0iTTUwIDUwIEMzMCAzMCAxMCAzMCAxMCA1MCBDMTAgODAgNTAgODAgNTAgNTAgWiIgZmlsbD0iI2ZmODBhYiIgb3BhY2l0eT0iMC44IiAvPgogIDxjaXJjbGUgY3g9IjUwIiBjeT0iNTUiIHI9IjUiIGZpbGw9IiNmZmYiIC8+Cjwvc3ZnPg==",
                scale: 1.4, yOffset: -15,
                // èƒŒæ™¯ï¼šå¾¡èŠ±åœ’ï¼ˆæ¡ƒèŠ±ç²‰ï¼‰
                bgType: "garden"
            },
            {
                name: "é£›å¤©ç«",
                // å·²ä¿®å¾© Base64 (èˆŠçš„æœ‰æå£å­—ç¬¦)
                src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBkPSJNNTAgMTAgUTcwIDUwIDkwIDYwIFE5MCA5MCA1MCA5NSBRMTAgOTAgMTAgNjAgUTMwIDUwIDUwIDEwIFoiIGZpbGw9IiNmZjM1MDUiIC8+PC9zdmc+",
                scale: 1.1, yOffset: -12,
                // èƒŒæ™¯ï¼šæ•¦ç…Œå£ç•«ï¼ˆèµ­çŸ³ + åœŸé»ƒï¼‰
                bgType: "dunhuang"
            },
            {
                name: "çç é»",
                // ç²‰è‰²çç ï¼Œå¸¶é«˜å…‰æ•ˆæœ
                src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSIzNSIgZmlsbD0iI2Y4YmJkMCIgc3Ryb2tlPSIjZTkxZTYzIiBzdHJva2Utd2lkdGg9IjMiLz48Y2lyY2xlIGN4PSIzOCIgY3k9IjM4IiByPSIxMiIgZmlsbD0iI2ZmZiIgb3BhY2l0eT0iMC42Ii8+PC9zdmc+",
                scale: 0.9, yOffset: -8,
                // èƒŒæ™¯ï¼šæœˆä¸‹é•·å®‰ï¼ˆå¤œæ™¯ï¼‰
                bgType: "changan"
            },
            {
                name: "ç¥¥é›²éˆ¿",
                // ç´«è‰²ç¥¥é›²åœ–æ¡ˆ
                src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBkPSJNMjUgNTUgUTE1IDQ1IDI1IDM1IFE0MCAyNSA1NSAzNSBRNzAgMjUgODAgNDAgUTkwIDU1IDc1IDY1IFE2MCA3NSA0NSA2NSBRMzAgNzUgMjUgNTUgWiIgZmlsbD0iIzljMjdiMCIgb3BhY2l0eT0iMC44NSIvPjxjaXJjbGUgY3g9IjUyIiBjeT0iNTAiIHI9IjEwIiBmaWxsPSIjZTFiZWU3Ii8+PC9zdmc+",
                scale: 1.3, yOffset: -18,
                // èƒŒæ™¯ï¼šä»™å¢ƒé›²æµ·
                bgType: "cloudSea"
            },
            {
                name: "é³³ç¾½ç¿",
                // é³³å‡°ç¾½æ¯›ï¼Œé‡‘æ©™è‰²
                src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBkPSJNNTAgNSBRNzAgMjUgNzUgNTAgUTgwIDc1IDUwIDk1IFEyMCA3NSAyNSA1MCBRMzAgMjUgNTAgNSBaIiBmaWxsPSIjZmY2ZjAwIi8+PHBhdGggZD0iTTUwIDIwIFE2MCAzNSA2MiA1MCBRNjUgNjUgNTAgODAgUTM1IDY1IDM4IDUwIFE0MCAzNSA1MCAyMCBaIiBmaWxsPSIjZmZjYzgwIi8+PC9zdmc+",
                scale: 1.2, yOffset: -15,
                // èƒŒæ™¯ï¼šé³³å‡°å°ï¼ˆçš‡å®¶ç´«é‡‘ï¼‰
                bgType: "phoenix"
            }
        ];

        // --- 2. è®Šé‡ ---
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const cursor = document.getElementById('hand-cursor');
        const statusText = document.getElementById('status-text');
        const startBtn = document.getElementById('start-btn');
        const overlay = document.getElementById('overlay');
        const resetBtn = document.getElementById('btn-reset');
        
        let selectedIndex = -1;
        let loadedImages = [];
        
        // æ ¸å¿ƒæ¨¡å‹
        let faceMesh, hands, selfieSegmentation;
        let isCameraRunning = false;
        
        // æ•¸æ“šç·©å­˜ (ç”¨æ–¼æ¸²æŸ“å¾ªç’°åˆæˆ)
        let latestFaceLandmarks = null;
        let latestHandLandmarks = null;
        let latestSegmentationMask = null;

        // æ‰‹å‹¢äº¤äº’è®Šé‡
        let isPinching = false;
        let lastClickTime = 0;
        let lastHoveredElement = null;

        // --- 3. åˆå§‹åŒ–è³‡æº ---
        function initImages() {
            const grid = document.getElementById('options-grid');
            huadianAssets.forEach((asset, index) => {
                const img = new Image();
                img.src = asset.src;
                loadedImages.push(img);

                const btn = document.createElement('div');
                btn.className = 'huadian-btn';
                btn.id = `btn-${index}`;
                btn.dataset.index = index;
                btn.innerHTML = `<img src="${asset.src}"><div class="huadian-name">${asset.name}</div>`;
                grid.appendChild(btn);
            });
            resetBtn.dataset.action = "reset";
        }

        function triggerClick(element) {
            const now = Date.now();
            if (now - lastClickTime < 1000) return;
            lastClickTime = now;

            element.classList.add('active');
            setTimeout(() => element.classList.remove('active'), 200);

            if (element.classList.contains('huadian-btn')) {
                const index = parseInt(element.dataset.index);
                selectHuadian(index);
            } else if (element.id === 'btn-reset') {
                selectHuadian(-1);
            }
        }

        function selectHuadian(index) {
            selectedIndex = index;
            document.querySelectorAll('.huadian-btn').forEach((btn, i) => {
                if (i === index) btn.classList.add('active');
                else btn.classList.remove('active');
            });
            // é¸æ“‡æ™‚ï¼ŒèƒŒæ™¯æ›¿æ›é‚è¼¯æœƒåœ¨ renderLoop ä¸­è‡ªå‹•è®€å– selectedIndex
        }

        // --- 4. åˆå§‹åŒ–æ‰€æœ‰æ¨¡å‹ ---
        async function initModels() {
            try {
                // A. Face Mesh (äººè‡‰)
                faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
                faceMesh.setOptions({maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
                faceMesh.onResults(results => {
                    if(results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                        latestFaceLandmarks = results.multiFaceLandmarks[0];
                    } else {
                        latestFaceLandmarks = null;
                    }
                });
                await faceMesh.initialize();

                // B. Hands (æ‰‹å‹¢)
                hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
                hands.onResults(results => {
                    if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        latestHandLandmarks = results.multiHandLandmarks[0];
                        processHandGestures(results.multiHandLandmarks[0]); // ç«‹å³è™•ç†äº¤äº’
                    } else {
                        latestHandLandmarks = null;
                        cursor.style.display = 'none';
                    }
                });
                await hands.initialize();

                // C. Selfie Segmentation (èƒŒæ™¯æ›¿æ›)
                selfieSegmentation = new SelfieSegmentation({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`});
                selfieSegmentation.setOptions({modelSelection: 1}); // 1 = landscape (faster?)
                selfieSegmentation.onResults(results => {
                    latestSegmentationMask = results.segmentationMask;
                });
                await selfieSegmentation.initialize();

                statusText.innerText = "å¦å¥©å·²å‚™å¥½ï¼Œè«‹é–‹å•Ÿé¡é ­";
                startBtn.style.display = 'inline-block';

            } catch (error) {
                console.error(error);
                statusText.innerText = "æ¨¡å‹åŠ è¼‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡é€£æ¥ (éœ€è¦åŠ è¼‰ç´„ 10MB æ¨¡å‹æ–‡ä»¶)";
            }
        }

        // --- 5. è¦–é »è™•ç†å¾ªç’° ---
        startBtn.onclick = async function() {
            statusText.innerText = "æ­£åœ¨å•Ÿå‹•é¡é ­...";
            startBtn.style.display = 'none';
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: "user" }
                });
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    overlay.style.display = 'none';
                    isCameraRunning = true;
                    processVideo(); // æ•¸æ“šç™¼é€å¾ªç’°
                    renderLoop();   // ç•«é¢ç¹ªè£½å¾ªç’°
                };
            } catch (err) {
                console.error(err);
                statusText.innerText = "ç„¡æ³•è¨ªå•æ”åƒé ­";
            }
        };

        // å¾ªç’°ç™¼é€æ•¸æ“šçµ¦æ¨¡å‹
        async function processVideo() {
            if (!isCameraRunning) return;
            
            // ç‚ºäº†ä¸å¡é “ï¼Œæˆ‘å€‘å¯ä»¥é¸æ“‡æ€§è·³å¹€æˆ–è€…ä¸¦è¡Œ
            // ä¸¦è¡Œç™¼é€
            try {
                const sends = [
                    faceMesh.send({image: videoElement}),
                    hands.send({image: videoElement})
                ];
                
                // åªæœ‰åœ¨é¸æ“‡äº†èŠ±éˆ¿æ™‚ï¼Œæ‰é–‹å•ŸèƒŒæ™¯åˆ†å‰² (ç¯€çœæ€§èƒ½)
                if (selectedIndex !== -1) {
                    sends.push(selfieSegmentation.send({image: videoElement}));
                } else {
                    latestSegmentationMask = null; // å¸å¦æ™‚æ¸…é™¤è’™ç‰ˆ
                }

                await Promise.all(sends);

            } catch(e) { console.warn(e); }

            if (isCameraRunning) requestAnimationFrame(processVideo);
        }

        // --- 6. æ ¸å¿ƒæ¸²æŸ“å¾ªç’° (Compositing) ---
        function renderLoop() {
            if (!isCameraRunning) return;

            // ç¢ºä¿ Canvas å°ºå¯¸
            if (canvasElement.width !== videoElement.videoWidth) {
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
            }

            const w = canvasElement.width;
            const h = canvasElement.height;

            // æ¸…ç©º
            canvasCtx.clearRect(0, 0, w, h);

            // A. èƒŒæ™¯èˆ‡äººç‰©ç¹ªè£½
            if (selectedIndex !== -1 && latestSegmentationMask) {
                // === è™›æ“¬èƒŒæ™¯æ¨¡å¼ ===
                
                // 1. ç¹ªè£½è’™ç‰ˆ
                canvasCtx.save();
                canvasCtx.drawImage(latestSegmentationMask, 0, 0, w, h);
                
                // 2. æ‡‰ç”¨è’™ç‰ˆï¼šä¿ç•™è’™ç‰ˆä¸é€æ˜å€åŸŸ(äººç‰©)
                canvasCtx.globalCompositeOperation = 'source-in';
                canvasCtx.drawImage(videoElement, 0, 0, w, h);

                // 3. ç¹ªè£½èƒŒæ™¯ï¼šåœ¨äººç‰©ä¹‹å¾Œç¹ªè£½
                canvasCtx.globalCompositeOperation = 'destination-over';
                drawBackground(canvasCtx, w, h, huadianAssets[selectedIndex].bgType);

                // 4. æ¢å¾©æ­£å¸¸ç¹ªè£½æ¨¡å¼ (ç‚ºäº†ä¹‹å¾Œç•«èŠ±éˆ¿)
                canvasCtx.globalCompositeOperation = 'source-over';
                canvasCtx.restore();

            } else {
                // === æ™®é€šæ¨¡å¼ (å¸å¦ç‹€æ…‹) ===
                canvasCtx.drawImage(videoElement, 0, 0, w, h);
            }

            // B. ç¹ªè£½èŠ±éˆ¿
            if (latestFaceLandmarks && selectedIndex !== -1) {
                drawHuadian(latestFaceLandmarks, selectedIndex);
            }

            requestAnimationFrame(renderLoop);
        }

        // --- 7. è¼”åŠ©ç¹ªåœ–å‡½æ•¸ ---

        function drawBackground(ctx, w, h, type) {
            let gradient;
            switch(type) {
                case 'peony': // æ´›é™½ç‰¡ä¸¹èŠ±æµ·
                    // 1. å¤©ç©º
                    gradient = ctx.createLinearGradient(0, 0, 0, h);
                    gradient.addColorStop(0, "#87CEEB"); // è—å¤©
                    gradient.addColorStop(0.3, "#e0f7fa"); // ç™½é›²
                    gradient.addColorStop(0.35, "#2e7d32"); // é è™•ç¶ æ„
                    
                    // 2. èŠ±æµ· (ç”¨å¸¶ç‹€æ¼¸è®Šæ¨¡æ“¬å±¤å±¤èŠ±æµª)
                    gradient.addColorStop(0.4, "#d81b60"); // ç‰¡ä¸¹ç´…
                    gradient.addColorStop(0.55, "#f06292"); // ç‰¡ä¸¹ç²‰
                    gradient.addColorStop(0.7, "#880e4f"); // æ·±ç´…
                    gradient.addColorStop(0.85, "#4caf50"); // ç¶ è‘‰
                    gradient.addColorStop(1, "#2e7d32"); // è¿‘è™•è‰åœ°
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                    
                    // 3. ç°¡å–®çš„å¤ªé™½
                    ctx.beginPath();
                    ctx.arc(w * 0.8, h * 0.15, 40, 0, 2 * Math.PI);
                    ctx.fillStyle = "rgba(255, 235, 59, 0.6)";
                    ctx.fill();
                    break;
                    
                case 'daming': // å¤§æ˜å®®ï¼šç¡ƒç´…èˆ‡é‡‘ç¢§è¼ç…Œ
                    gradient = ctx.createRadialGradient(w/2, h/2, 10, w/2, h/2, w);
                    gradient.addColorStop(0, "#8e0000");
                    gradient.addColorStop(1, "#3a0000");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                    // é‡‘è‰²é‚Šæ¡†æ„Ÿ
                    ctx.strokeStyle = "rgba(255, 215, 0, 0.3)";
                    ctx.lineWidth = 20;
                    ctx.strokeRect(10, 10, w-20, h-20);
                    break;
                case 'jiangnan': // æ±Ÿå—ï¼šé’ç¶ å±±æ°´
                    gradient = ctx.createLinearGradient(0, 0, 0, h);
                    gradient.addColorStop(0, "#a1c4fd"); // å¤©é’
                    gradient.addColorStop(1, "#c2e9fb");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                    ctx.fillStyle = "rgba(0, 100, 0, 0.1)"; // é å±±æ„è±¡
                    ctx.beginPath();
                    ctx.moveTo(0, h); ctx.lineTo(w, h); ctx.lineTo(w, h*0.6); ctx.lineTo(0, h*0.8);
                    ctx.fill();
                    break;
                case 'garden': // å¾¡èŠ±åœ’ï¼šç²‰è‰²æµªæ¼«
                    gradient = ctx.createLinearGradient(0, 0, w, h);
                    gradient.addColorStop(0, "#fad0c4");
                    gradient.addColorStop(1, "#ffd1ff");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                    break;
                case 'dunhuang': // æ•¦ç…Œï¼šæ²™æ¼ èˆ‡å£ç•«
                    gradient = ctx.createLinearGradient(0, 0, w, 0);
                    gradient.addColorStop(0, "#d35400");
                    gradient.addColorStop(1, "#e67e22");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                    break;
                case 'changan': // æœˆä¸‹é•·å®‰ï¼šå¤œæ™¯
                    gradient = ctx.createLinearGradient(0, 0, 0, h);
                    gradient.addColorStop(0, "#0d1b2a"); // æ·±è—å¤œç©º
                    gradient.addColorStop(0.4, "#1b263b");
                    gradient.addColorStop(1, "#415a77");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                    // æœˆäº®
                    ctx.beginPath();
                    ctx.arc(w * 0.75, h * 0.2, 50, 0, 2 * Math.PI);
                    ctx.fillStyle = "rgba(255, 250, 205, 0.9)";
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(w * 0.78, h * 0.18, 45, 0, 2 * Math.PI);
                    ctx.fillStyle = "#0d1b2a";
                    ctx.fill();
                    // æ˜Ÿæ˜Ÿ
                    for (let i = 0; i < 30; i++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * w, Math.random() * h * 0.5, Math.random() * 2, 0, 2 * Math.PI);
                        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                        ctx.fill();
                    }
                    break;
                case 'cloudSea': // ä»™å¢ƒé›²æµ·
                    gradient = ctx.createLinearGradient(0, 0, 0, h);
                    gradient.addColorStop(0, "#e8daef"); // æ·ºç´«
                    gradient.addColorStop(0.3, "#d2b4de");
                    gradient.addColorStop(0.6, "#f5eef8");
                    gradient.addColorStop(1, "#fdfefe");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                    // é›²å±¤
                    ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
                    for (let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        let cx = Math.random() * w;
                        let cy = h * 0.5 + Math.random() * h * 0.3;
                        ctx.ellipse(cx, cy, 120 + Math.random() * 80, 40 + Math.random() * 30, 0, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    break;
                case 'phoenix': // é³³å‡°å°ï¼šçš‡å®¶ç´«é‡‘
                    gradient = ctx.createRadialGradient(w/2, h/2, 10, w/2, h/2, w * 0.8);
                    gradient.addColorStop(0, "#4a148c"); // æ·±ç´«
                    gradient.addColorStop(0.5, "#6a1b9a");
                    gradient.addColorStop(1, "#1a0033");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                    // é‡‘è‰²å…‰èŠ’
                    ctx.strokeStyle = "rgba(255, 215, 0, 0.15)";
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 12; i++) {
                        ctx.beginPath();
                        ctx.moveTo(w/2, h/2);
                        let angle = (i / 12) * Math.PI * 2;
                        ctx.lineTo(w/2 + Math.cos(angle) * w, h/2 + Math.sin(angle) * h);
                        ctx.stroke();
                    }
                    // é‡‘è‰²é‚Šæ¡†
                    ctx.strokeStyle = "rgba(255, 215, 0, 0.4)";
                    ctx.lineWidth = 15;
                    ctx.strokeRect(15, 15, w-30, h-30);
                    break;
                default: // é¾é–€çŸ³çªŸ (ä½œç‚ºå‚™ç”¨æˆ–ä¹‹å‰çš„é»˜èª)
                    gradient = ctx.createLinearGradient(0, 0, 0, h);
                    gradient.addColorStop(0, "#2c3e50");
                    gradient.addColorStop(1, "#bdc3c7");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
            }
        }

        function drawHuadian(landmarks, index) {
            const w = canvasElement.width;
            const h = canvasElement.height;
            const config = huadianAssets[index];
            const img = loadedImages[index];
            
            // å®‰å…¨æª¢æŸ¥ï¼šç¢ºä¿åœ–ç‰‡å·²åŠ è¼‰ä¸”æœ‰æ•ˆ
            if (!img || !img.complete || img.naturalWidth === 0) return;

            const pt151 = landmarks[151];
            const cx = pt151.x * w;
            const cy = pt151.y * h + config.yOffset;

            const ptLeft = landmarks[33];
            const ptRight = landmarks[263];
            const dx = (ptRight.x - ptLeft.x) * w; 
            const dy = (ptRight.y - ptLeft.y) * h;
            const angle = Math.atan2(dy, dx);

            const tL = landmarks[127];
            const tR = landmarks[356];
            const dist = Math.sqrt(Math.pow((tL.x - tR.x)*w, 2) + Math.pow((tL.y - tR.y)*h, 2));
            
            // --- å°ºå¯¸å„ªåŒ– ---
            // ä¹‹å‰çš„ä¿‚æ•¸æ˜¯ 0.4ï¼Œç¾åœ¨ç¸®å° 30% -> 0.4 * 0.7 = 0.28
            const size = dist * 0.28 * config.scale;

            canvasCtx.save();
            canvasCtx.translate(cx, cy);
            canvasCtx.rotate(angle);
            canvasCtx.drawImage(img, -size/2, -size/2, size, size);
            canvasCtx.restore();
        }

        // --- 8. æ‰‹å‹¢è™•ç† (ç¨ç«‹é‚è¼¯) ---
        function processHandGestures(landmarks) {
            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];

            // é¡åƒåº§æ¨™è½‰æ›
            const cursorX = (1 - indexTip.x) * window.innerWidth;
            const cursorY = indexTip.y * window.innerHeight;

            cursor.style.display = 'block';
            cursor.style.left = `${cursorX}px`;
            cursor.style.top = `${cursorY}px`;

            const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
            const pinchThreshold = 0.05;

            // äº¤äº’æª¢æ¸¬
            const elements = document.elementsFromPoint(cursorX, cursorY);
            let targetBtn = null;
            for (let el of elements) {
                if (el.classList.contains('huadian-btn') || el.classList.contains('reset-btn')) {
                    targetBtn = el;
                    break;
                }
            }

            if (lastHoveredElement && lastHoveredElement !== targetBtn) {
                lastHoveredElement.classList.remove('hover');
            }
            if (targetBtn) {
                targetBtn.classList.add('hover');
                lastHoveredElement = targetBtn;
            }

            if (pinchDist < pinchThreshold) {
                if (!isPinching) {
                    cursor.classList.add('clicking');
                    if (targetBtn) triggerClick(targetBtn);
                }
                isPinching = true;
            } else {
                cursor.classList.remove('clicking');
                isPinching = false;
            }
        }

        // å•Ÿå‹•
        initImages();
        initModels();

    </script>
</body>
</html>